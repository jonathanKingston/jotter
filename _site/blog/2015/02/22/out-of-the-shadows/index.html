<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Out of the shadows</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://jotter.jonathankingston.co.uk/blog/2015/02/22/out-of-the-shadows/">
  <link rel="alternate" type="application/rss+xml" title="Jonathan Kingston" href="http://jotter.jonathankingston.co.uk/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Jonathan Kingston</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Out of the shadows</h1>
    <p class="post-meta"><time datetime="2015-02-22T04:18:00+00:00" itemprop="datePublished">Feb 22, 2015</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><img src="/images/shadow/shadow-puppet.jpg" alt="Shadow puppet" /></p>

<p><strong>Disclaimer</strong> - This article discusses topics which are not cemented yet, may change and likely won’t work without browser shims / hacks. This article uses <code class="highlighter-rouge">&lt;"shadow-tree"&gt;&lt;/&gt;</code> syntax like the CSS specification does to demarcate the shadow tree in the DOM.</p>

<p>So we have all likely heard of web components by now; they are usable in most JavaScript libraries and are the UI kit that is expected of any GUI related software.</p>

<p>However one of the least discussed features of web components is the <a href="http://www.w3.org/TR/shadow-dom/">Shadow DOM</a> and even less discussed is how it can be styled with scoped styles.</p>

<p>Shadow DOM is the way in which developers will be able to hide away the minor details of website implementation, this means that template authors won’t need to worry as much about perfecting their markup and concentrate on the building block they are trying to make. A great example of this is select boxes native in browsers, content authors don’t need to worry about all the complexities of the buttons and functionality. The author can then just give some basic styling to the select box.</p>

<p>So I hear you cry, why is this different to normal components that give us the ability to define our own web language and reuse. Well I think it solves the issue of specificity - by defining the boundaries of reusable objects, you gain the ability to isolate styles when necessary.</p>

<!-- more -->

<h4 id="before-dom-render">Before DOM render</h4>

<p><img src="/images/shadow/before-render.png" alt="Before render" /></p>

<p>Elements are nested under the Shadow host n1.</p>

<h4 id="after-dom-render">After DOM render</h4>

<p><img src="/images/shadow/after-render.png" alt="After render" /></p>

<p>Once rendered, elements that are not a Shadow route are nested under the DOM insertion point <code class="highlighter-rouge">&lt;content&gt;</code></p>

<div class="language-html highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;my-element&gt;</span><span class="c">&lt;!-- Shadow host --&gt;</span>
  <span class="err">&lt;</span>"shadow-tree"&gt;<span class="c">&lt;!-- A non element --&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"title"</span><span class="nt">&gt;</span>Some text<span class="nt">&lt;/div&gt;</span>
    <span class="c">&lt;!-- CSS inside a shadow DOM is treated as scoped --&gt;</span>
    <span class="nt">&lt;style&gt;</span>
      <span class="o">//</span><span class="nt">my-element</span> <span class="nt">won</span><span class="err">'</span><span class="nt">t</span> <span class="nt">match</span> <span class="nt">anything</span> <span class="nt">here</span><span class="o">,</span> <span class="nt">use</span> <span class="nd">:host</span> <span class="nt">instead</span>
      <span class="nt">my-element</span> <span class="p">{</span>
        <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="o">//</span><span class="nd">:host</span> <span class="nt">selector</span> <span class="nt">here</span> <span class="nt">will</span> <span class="nt">match</span> <span class="nt">my-element</span>
      <span class="nd">:host</span> <span class="p">{</span>
        <span class="nl">color</span><span class="p">:</span> <span class="no">blue</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="o">&lt;/</span><span class="nt">style</span><span class="o">&gt;</span>
  <span class="o">&lt;/&gt;</span>
<span class="o">&lt;/</span><span class="nt">my-element</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="nt">style</span><span class="o">&gt;</span>
  <span class="o">//</span><span class="nt">Matches</span> <span class="nc">.title</span> <span class="nt">element</span>
  <span class="nt">my-element</span><span class="nd">::shadow</span> <span class="nt">div</span> <span class="p">{</span>
    <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="o">//</span><span class="nt">Applies</span> <span class="nt">to</span> <span class="nt">the</span> <span class="nt">content</span> <span class="nt">div</span> <span class="nt">elements</span>
  <span class="o">//</span><span class="nt">not</span> <span class="nt">ones</span> <span class="nt">residing</span> <span class="nt">in</span> <span class="nt">the</span> <span class="nt">shadow</span> <span class="nt">DOM</span> <span class="nc">.title</span> <span class="nt">would</span> <span class="nt">not</span> <span class="nt">match</span>
  <span class="nt">my-element</span> <span class="nt">div</span> <span class="p">{</span>
    <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
  <span class="p">}</span>  
<span class="nt">&lt;/style&gt;</span>
</code></pre>
</div>

<h3 id="so-why-does-it-matter-to-me">So why does it matter to me?</h3>

<ul>
  <li>Shadow DOM provides a encapsulation layer that means multiple teams can work on the same HTML documents without worries of colliding CSS.</li>
  <li>Flexibility still remains to “select through the shadows” so you can override the default appearance of a component.</li>
  <li>Content authors can concentrate on styling usage rather than implementation.</li>
  <li>Component developers can concentrate on building the most reusable components possible.</li>
  <li>No amount of namespacing gives the isolation that Shadow DOM gives.
    <ul>
      <li>Nested HTML that is namespaced still has specificity issues, where as isolation gives easier container selection.</li>
    </ul>
  </li>
</ul>

<p>Chrome debugger even helps show the DOM tree:</p>

<p><img src="/images/shadow/debugger.png" alt="Debugger output" /></p>

<p><a href="http://html5-demos.appspot.com/static/shadowdom-visualizer/index.html">Visualise shadow DOM</a></p>

<h3 id="shadow-dom-concepts">Shadow DOM concepts</h3>

<ul>
  <li><a href="http://w3c.github.io/webcomponents/spec/shadow/#dfn-shadow-host"><strong>Shadow host</strong></a> - is the container of one or many <strong>Shadow trees</strong>
    <ul>
      <li>Elements within the <strong>Shadow host</strong> are detached until they match a DOM insertion point</li>
      <li>The last <strong>Shadow tree</strong> inserted into the <strong>Shadow host</strong> is the only attached Node to the host.
        <ul>
          <li>Older <strong>Shadow trees</strong> can be inserted into the newest shadow tree with a <strong>Shadow insertion point</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="http://w3c.github.io/webcomponents/spec/shadow/#dfn-insertion-point"><strong>Shadow insertion point</strong></a> When a host has multiple <strong>Shadow trees</strong> the trees can be reinserted into the newest tree if it has an insertion point.
    <ul>
      <li><code class="highlighter-rouge">&lt;shadow&gt;</code> is the current only implementation of a <strong>Shadow insertion point</strong></li>
    </ul>
  </li>
  <li><a href="http://w3c.github.io/webcomponents/spec/shadow/#insertion-points"><strong>DOM insertion point</strong></a> - At the moment this is a <code class="highlighter-rouge">&lt;content&gt;</code> tag within the shadow DOM however other implementations may happen
    <ul>
      <li>An insertion point has the elements placed into it inside the <em>Shadow tree</em></li>
      <li>Insertion points has no representation in the DOM, it is just a container for elements.</li>
      <li>Insertion points match the elements in the <em>Shadow host</em></li>
    </ul>
  </li>
  <li><a href="http://w3c.github.io/webcomponents/spec/shadow/#shadow-trees"><strong>Shadow trees</strong></a> - A tree of elements which are abstracted away from the normal DOM tree
    <ul>
      <li><strong>Shadow trees</strong> detach all elements from the <strong>Shadow host</strong></li>
    </ul>
  </li>
</ul>

<h3 id="a-simpler-implementation-the-design">A simpler implementation (The design)</h3>

<p>However we can vastly simplify this for the most common usage with custom elements;</p>

<ul>
  <li>Create a new custom element</li>
  <li>A <strong>Shadow tree</strong> is added to the custom element (Making the custom element a <strong>shadow host</strong>)</li>
  <li>A template of DOM nodes is cloned and inserted into the <strong>Shadow tree</strong></li>
  <li>Elements that are contained in the custom element are either detached from the DOM
    <ul>
      <li>Or if the template has a <code class="highlighter-rouge">&lt;content&gt;</code> tag the elements are inserted within that.</li>
    </ul>
  </li>
</ul>

<p>Assuming we have some code building the custom elements (see final example), the following code:
```html</p>
<template id="mycustomelement">
  <div>
    <content></content>
  </div>
</template>

<my-custom-element>
  <b>Hello</b>
</my-custom-element>
<div class="highlighter-rouge"><pre class="highlight"><code>
Will result in the following DOM tree:
```html
&lt;my-custom-element&gt;
  &lt;div&gt;
    &lt;b&gt;Hello&lt;/b&gt;
  &lt;/div&gt;
&lt;/my-custom-element&gt;
</code></pre>
</div>

<h2 id="javascript-implementation">JavaScript implementation</h2>

<h3 id="registering-a-component">Registering a component</h3>

<p>Registering a new component is our first step to getting to the design set out above.</p>

<p>Let’s register a new component called <code class="highlighter-rouge">product-demo</code> and register it to the global <code class="highlighter-rouge">window.productDemo</code>.</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">//Create a custom element that extends from the base HTMLElement</span>
<span class="kd">var</span> <span class="nx">productDemoPrototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">HTMLElement</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>

<span class="c1">//Register the element name to the window</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">productDemo</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">registerElement</span><span class="p">(</span><span class="s1">'product-demo'</span><span class="p">,</span> <span class="p">{</span><span class="na">prototype</span><span class="p">:</span> <span class="nx">productDemoPrototype</span><span class="p">});</span>
</code></pre>
</div>

<p>We can use the element before we define it in the JavaScript as HTML5 allows for custom elements that are not defined yet. However if we define custom behaviour to the <code class="highlighter-rouge">window.productDemo</code> once the element is created this behaviour get applied to the element.</p>

<p>Customising the new element becomes simple with the new method <a href="http://www.w3.org/TR/custom-elements/#dfn-created-callback">createdCallback</a> on the defined element. The callback is triggered when a new element instance is created, this gives us the ability to add custom behaviour on initialisation.</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">productDemo</span><span class="p">.</span><span class="nx">createdCallback</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'New product-demo created'</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>
</div>

<h3 id="attaching-a-template">Attaching a template</h3>

<p>Web Components doesn’t require us to use <code class="highlighter-rouge">&lt;template&gt;</code> tags however they make writing the innards of a shadow simpler by being in a self contained placeholder.</p>

<div class="language-html highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;template&gt;</span>
  <span class="nt">&lt;h2&gt;</span>Product name<span class="nt">&lt;/h2&gt;</span>
  <span class="nt">&lt;div&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/template&gt;</span>
</code></pre>
</div>

<p>Templates are just a simple blueprint for DOM nodes that have to be cloned to be inserted into the DOM:
<code class="highlighter-rouge">javascript
var template = document.querySelector(templateSelector);
var clone = document.importNode(template.content, true);
document.body.appendChild(clone);
</code></p>

<p>The problem with this is that however complex the template, there is nothing dynamic to the component yet. However later on we will see that we use the <code class="highlighter-rouge">createdCallback</code> to add in functionality from passed attributes to our custom elements.</p>

<h3 id="adding-a-shadow-dom">Adding a shadow DOM</h3>

<p><a href="http://w3c.github.io/webcomponents/spec/shadow/#widl-Element-createShadowRoot-ShadowRoot">Element.createShadowRoot</a> creates a shadow root on the element.</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">Element</span><span class="p">.</span><span class="nx">createShadowRoot</span><span class="p">();</span>
</code></pre>
</div>

<p>By adding this to an element it turns the element into a <strong>shadow host</strong> which in terms of JavaScript is similar to <code class="highlighter-rouge">document.createDocumentFragment</code> in that it isn’t a real element in the conventional sense.</p>

<h2 id="scoping-css">Scoping CSS</h2>

<p>Scoped styles are the main advantage to Shadow DOM in that the selectors exposed allow web component developers to be able to ‘black box’ their code appearance unless the user of the component explicitly wanted to style within the component.</p>

<p>Styles within the shadow DOM are scoped to the <strong>Shadow root</strong> rather than document wide as they normally would be.</p>

<p>Styles from the outside of the shadow are unable to select into the shadow unless using the selectors defined below. This means that as a template author I can’t select by mistake the innards of the shadow which means the components become very self contained. Rules like <code class="highlighter-rouge">color</code> will be inherited into the shadow unless the shadow defines its own rules for those properties which would take a higher specificity.</p>

<div class="language-css highlighter-rouge"><pre class="highlight"><code><span class="o">//</span><span class="nt">This</span> <span class="nt">has</span> <span class="nt">a</span> <span class="nt">shadow</span> <span class="nt">DOM</span> <span class="nt">applied</span>
<span class="nt">my-component</span> <span class="p">{</span>
  <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span><span class="nt">This</span> <span class="nt">matches</span> <span class="nt">all</span> <span class="nt">elements</span> <span class="nt">which</span> <span class="nt">are</span><span class="o">:</span>  <span class="err">"</span><span class="nt">my-component</span> <span class="o">&lt;</span><span class="err">"</span><span class="nt">shadow</span> <span class="nt">tree</span><span class="err">"</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nt">content</span><span class="o">&gt;</span> <span class="nt">span</span><span class="err">"</span>
<span class="o">//</span><span class="nt">This</span> <span class="nt">won</span><span class="err">'</span><span class="nt">t</span> <span class="nt">match</span> <span class="nt">span</span> <span class="nt">elements</span> <span class="nt">within</span> <span class="nt">the</span> <span class="nt">shadow</span> <span class="nt">tree</span>
<span class="nt">my-component</span> <span class="nt">span</span> <span class="p">{</span>
  <span class="nl">color</span><span class="p">:</span> <span class="no">blue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p><a href="http://drafts.csswg.org/css-scoping/">CSS Scoping specification</a> defines ways in which we can utilise CSS to get over those age old specificity woes.</p>

<p>The spec brings along some new friends which will really be useful for working with shadow DOM:</p>

<h3 id="selectors-from-the-outside">Selectors from the outside</h3>

<h4 id="shadowhttpdraftscsswgorgcss-scopingshadow-pseudoelement"><a href="http://drafts.csswg.org/css-scoping/#shadow-pseudoelement">::shadow</a></h4>
<p><code class="highlighter-rouge">::shadow</code> can be used to override the components styles within the shadow DOM allowing you to pierce through the shadow and pick out elements within it.</p>

<h4 id="httpdraftscsswgorgcss-scopingdeep-combinator"><a href="http://drafts.csswg.org/css-scoping/#deep-combinator">»&gt;</a></h4>

<p><code class="highlighter-rouge">&gt;&gt;&gt;</code> deep shadow selector, through multiple layers of shadow DOM. This selects all the matching elements through the shadow including DOM insertion point content also.
Chrome doesn’t even support this selector yet, <code class="highlighter-rouge">/deep/</code> was in the older version of the specification and is the current implemented version in Chrome unstable.</p>

<h4 id="unresolvedhttpw3cgithubiowebcomponentsspeccustomunresolved-element-pseudoclass-smallpart-of-the-web-component-specificationsmall"><a href="http://w3c.github.io/webcomponents/spec/custom/#unresolved-element-pseudoclass">:unresolved</a> <small>(part of the web component specification)</small></h4>

<p><code class="highlighter-rouge">:unresolved</code> can be used to target elements that have not yet been registered by the JavaScript. As all new web components are not native in the browser, until the elements are defined then the browsers considers web-component tags as ‘unresolved’ when the element is defined then the flag is removed from those elements. This means that the CSS author has full control of the behaviour of an element until the element is defined.
For example the author could pick to hide the elements or show a loading spinner.</p>

<div class="language-css highlighter-rouge"><pre class="highlight"><code><span class="o">//</span><span class="nt">Before</span> <span class="nt">my-custom-component</span> <span class="nt">is</span> <span class="nt">defined</span> <span class="nt">this</span> <span class="nt">will</span> <span class="nt">be</span> <span class="nt">the</span> <span class="nt">default</span> <span class="nt">appearance</span>
<span class="o">//</span><span class="nt">This</span> <span class="nt">prevents</span> <span class="nt">any</span> <span class="nt">flash</span> <span class="nt">of</span> <span class="nt">unstyled</span> <span class="nt">component</span>
<span class="nt">my-custom-component</span><span class="nd">:unresolved</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="selectors-from-the-inside">Selectors from the inside</h3>
<p>These selectors are for use within the Shadow DOM to select into the <code class="highlighter-rouge">&lt;content&gt;</code> element or matching certain <strong>Shadow host</strong> elements.</p>

<h4 id="contenthttpdraftscsswgorgcss-scopingcontent-combinator"><a href="http://drafts.csswg.org/css-scoping/#content-combinator">::content</a></h4>
<p><code class="highlighter-rouge">::content</code> is used to select the elements residing in the DOM insertion point. Used from within the shadow to select matching elements within the DOM insertion point.</p>

<p><code class="highlighter-rouge">::content</code> for me is important in that it helps us define relationships between other components:</p>

<div class="language-css highlighter-rouge"><pre class="highlight"><code><span class="o">//</span><span class="nt">product-demo</span><span class="nc">.css</span>
<span class="nd">::content</span> <span class="nt">product-image</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="nb">block</span><span class="p">;</span>
  <span class="nl">float</span><span class="p">:</span> <span class="nb">right</span><span class="p">;</span>
<span class="p">}</span>
<span class="nd">::content</span> <span class="nt">product-description</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="nb">block</span><span class="p">;</span>
  <span class="nl">float</span><span class="p">:</span> <span class="nb">left</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="hosthttpdraftscsswgorgcss-scopingselectordef-host-function"><a href="http://drafts.csswg.org/css-scoping/#selectordef-host-function">:host()</a></h4>
<p>Used from within a Shadow DOM to select the Shadow host that matches the selector within the brackets.
<code class="highlighter-rouge">
:host(.big) // From the styles within a shadow root this matches host elements that have an ancestor which match '.big'
</code></p>

<h4 id="hosthttpdraftscsswgorgcss-scopingselectordef-host"><a href="http://drafts.csswg.org/css-scoping/#selectordef-host">:host</a></h4>
<p><code class="highlighter-rouge">:host</code> is used for selecting the shadow host element from within the shadow DOM itself.</p>

<h4 id="host-contexthttpdraftscsswgorgcss-scopingselectordef-host-context"><a href="http://drafts.csswg.org/css-scoping/#selectordef-host-context">:host-context()</a></h4>
<p><code class="highlighter-rouge">:host-context</code> is used to select the parents of the host element from within the shadow context.</p>

<h1 id="putting-it-all-into-action">Putting it all into action</h1>

<p>Here is a simple function I made to define new elements with a shadow DOM.
```javascript
/**
 * Create callback
 * @callback createElementCallback
 * @param {element} shadow the shadow DOM element
 * @param {scope} this the scope of the custom element
 */</p>

<p>/**
 * Generates a new component
 * @param {string} elementName Name of JavaScript Class for the element
 * @param {string} tagName Name of the tag produced (Must contain at least one ‘-‘)
 * @param {string} templateSelector Selector to template for the contents of the shadow DOM
 * @param {createElementCallback} postCreateCallback Callback triggered on construction of the element
 */
function generateComponent(elementName, tagName, templateSelector, postCreateCallback) {</p>

<p>//Create a custom element that extends from the base HTMLElement
  var elementPrototype = Object.create(HTMLElement.prototype);</p>

<p>//On creation of an element this code triggers
  //Defines a shadow root within our custom element
  //Imports in the matching template
  //Triggers the callback for any further customisation
  elementPrototype.createdCallback = function() {
    var shadow = this.createShadowRoot();
    var template = document.querySelector(templateSelector);
    var clone = document.importNode(template.content, true);
    shadow.appendChild(clone);
    if (postCreateCallback) { postCreateCallback(shadow, this); }
  };</p>

<p>//Register the element name to the window
  window[elementName] = document.registerElement(tagName, {prototype: elementPrototype});
}
```</p>

<p>This sets up a new component which has a shadow DOM within it, the template specified will be inserted into shadow DOM which the function also sets up.</p>

<div class="language-html highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;my-element&gt;</span>
  <span class="err">&lt;</span>"Shadow tree"&gt;
    Template nodes here
  <span class="err">&lt;</span>/&gt;
<span class="nt">&lt;/my-element&gt;</span>
</code></pre>
</div>

<h2 id="example">Example</h2>

<p>Define some elements
```javascript
function slugify(slug) {
  return slug.toLowerCase().replace(/\s/g,’-‘);
}</p>

<p>generateComponent(‘MyBlockElement’, ‘my-block’, ‘#myblocktemplate’, function (shadow, scope) {
  var headingDOM = shadow.querySelector(‘my-heading’);
  var heading = scope.getAttribute(‘heading’);
  var icon = scope.getAttribute(‘heading-icon’);
  if (headingDOM) {
    if (heading) {
      headingDOM.innerText = heading;
    } else {
      headingDOM.style.display = ‘none’;
    }
    if (icon) {
      headingDOM.setAttribute(‘icon’, icon);
    }
  }
});</p>

<p>generateComponent(‘MyHeadingElement’, ‘my-heading’, ‘#myheadingtemplate’, function (shadow, scope) {
  var icon = scope.getAttribute(‘icon’);
  var iconDOM = shadow.querySelector(‘i’);
  var linkDOM = shadow.querySelector(‘a’);
  if (icon &amp;&amp; iconDOM) {
    iconDOM.classList.add(icon);
  }
  if (linkDOM &amp;&amp; scope.innerText !== ‘’) {
      linkDOM.setAttribute(‘href’, ‘#’ + slugify(scope.innerText));
  }
});
```</p>

<p>Define the component templates:
```html</p>
<template id="myheadingtemplate">
  <div>
    <i class="icon"></i>
    <h1>
      <content></content>
    </h1>
    <a href="#">#</a>
  </div>
  <style>
      i.icon:before {font-size:30px;}
      i.user:before {content: '☻';}
      i.pentagon:before {content: '⬟';}
      h1 {display: inline-block;}
  </style>
</template>

<template id="myblocktemplate">
  <div>
    <my-heading></my-heading>
    <content></content>
  </div>
  <style>
     div {
       border: 1px solid #000;
       padding: 5%;
       margin-bottom: 5%;
     }
  </style>
</template>
<div class="highlighter-rouge"><pre class="highlight"><code>&gt;**WHAT!?** I hear you cry, nested `&lt;style&gt;` tags within my component template? For now this is the simplest implementation for component scoped styles however rolling a custom `&lt;import` from separate assets later would be advised.
&gt;However the idea is that most components should be kept small so who knows this may become the common form as practices evolve.

Our actual template using the elements:
```html
&lt;my-block&gt;
  &lt;my-block heading-icon="user" heading="My important heading" &gt;
    &lt;div&gt;Lorem ipsum&lt;/div&gt;
  &lt;/my-block&gt;
    
  &lt;my-block heading-icon="pentagon" heading="My second heading" &gt;
    Lorem ipsum
  &lt;/my-block&gt;
&lt;/my-block&gt;
</code></pre>
</div>

<p>It is worth noting the same effect could be achieved with the same CSS outside the templates:
<code class="highlighter-rouge">css
my-heading::shadow div {
 border: 1px solid #000;
 padding: 5%;
 margin-bottom: 5%;
}
my-block::shadow i.icon:before {font-size:30px;}
my-block::shadow i.user:before {content: '☻';}
my-block::shadow i.pentagon:before {content: '⬟';}
my-block::shadow h1 {display: inline-block;}
</code>
<a href="http://codepen.io/anon/pen/dPeYGN">See this on CodePen</a></p>

<p>Which is lengthier however there are a few solutions to this:</p>

<ul>
  <li>Use LESS or Sass</li>
  <li>Use HTML imports to push the CSS into the element whilst still maintaining a separate CSS file
    <ul>
      <li>Drawback is <a href="https://hacks.mozilla.org/2014/12/mozilla-and-web-components/">Mozilla won’t be implementing import just yet</a></li>
    </ul>
  </li>
  <li>Use a shim to compile together the CSS, JS and HTML into a package similar to how other frameworks do for components now</li>
  <li>Shim support for <a href="http://tabatkins.github.io/specs/css-nesting/#the-nested-block">nested CSS</a></li>
</ul>

<h2 id="further-reading">Further reading</h2>
<ul>
  <li><a href="https://github.com/webcomponents/webcomponentsjs">Pollyfills</a></li>
  <li><a href="https://www.polymer-project.org/articles/styling-elements.html">Styling with polymer</a></li>
  <li><a href="https://github.com/webcomponents/webcomponents.github.io/blob/site/src/documents/articles/web-components-best-practices.html.md">Good practices with web components</a></li>
  <li><a href="https://github.com/inigo-llc/ember-polymer">Polymer in Ember-cli</a>
    <ul>
      <li><a href="https://gist.github.com/dnegstad/eee660aa32efd906082c">Derived from this gist</a></li>
    </ul>
  </li>
  <li><a href="http://robdodson.me/shadow-dom-css-cheat-sheet/">Shadow DOM CSS cheat sheet</a> - also has examples using polymer</li>
</ul>

<h2 id="credit">Credit</h2>
<ul>
  <li><a href="https://www.flickr.com/photos/double-m2/3945354161/">Picture by Double-M</a></li>
  <li><a href="http://www.xanthir.com/blog/">Question help from Tab Atkins</a></li>
</ul>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Jonathan Kingston</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Jonathan Kingston</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/jonathanKingston"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">jonathanKingston</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/kingstonTime"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">kingstonTime</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Notes from a developer in Nottingham.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
